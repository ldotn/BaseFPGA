
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DDR3_RTL(

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_SCK,
	output		          		ADC_SDI,
	input 		          		ADC_SDO,

	//////////// ARDUINO //////////
	inout 		    [15:0]		ARDUINO_IO,
	inout 		          		ARDUINO_RESET_N,
	
	///////// GPIO /////////
   inout       [35:0] GPIO_0,
   inout       [35:0] GPIO_1,
		

	//////////// CLOCK //////////
	input 		          		FPGA_CLK1_50,
	input 		          		FPGA_CLK2_50,
	input 		          		FPGA_CLK3_50,

	//////////// HDMI //////////
	inout 		          		HDMI_I2C_SCL,
	inout 		          		HDMI_I2C_SDA,
	inout 		          		HDMI_I2S,
	inout 		          		HDMI_LRCLK,
	inout 		          		HDMI_MCLK,
	inout 		          		HDMI_SCLK,
	output		          		HDMI_TX_CLK,
	output		          		HDMI_TX_DE,
	output		    [23:0]		HDMI_TX_D,
	output		          		HDMI_TX_HS,
	input 		          		HDMI_TX_INT,
	output		          		HDMI_TX_VS,

	//////////// HPS //////////
	output		    [14:0]		HPS_DDR3_ADDR,
	output		     [2:0]		HPS_DDR3_BA,
	output		          		HPS_DDR3_CAS_N,
	output		          		HPS_DDR3_CKE,
	output		          		HPS_DDR3_CK_N,
	output		          		HPS_DDR3_CK_P,
	output		          		HPS_DDR3_CS_N,
	output		     [3:0]		HPS_DDR3_DM,
	inout 		    [31:0]		HPS_DDR3_DQ,
	inout 		     [3:0]		HPS_DDR3_DQS_N,
	inout 		     [3:0]		HPS_DDR3_DQS_P,
	output		          		HPS_DDR3_ODT,
	output		          		HPS_DDR3_RAS_N,
	output		          		HPS_DDR3_RESET_N,
	input 		          		HPS_DDR3_RZQ,
	output		          		HPS_DDR3_WE_N,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [7:0]		LED,

	//////////// SW //////////
	input 		     [3:0]		SW
);


//=======================================================
//  REG/WIRE declarations
//=======================================================


wire DDR3_CLK;
wire Debounce_KEY0;
wire Debounce_KEY1;
//=======================================================
//  Structural coding
//=======================================================

debounce d0(
  .clk(FPGA_CLK2_50), 		
  .reset_n(1'b1), 
  .idebounce(KEY[0]),
  .odebounce(Debounce_KEY0)  
);


debounce d1(
  .clk(FPGA_CLK2_50), 		
  .reset_n(1'b1), 
  .idebounce(KEY[1]),
  .odebounce(Debounce_KEY1)  
);

 soc_system u0 (
		//Clock&Reset
	  .clk_clk                               ( FPGA_CLK1_50 ),                               //                            clk.clk
	  .ddr3_clk_clk                          ( DDR3_CLK ),                             //                    clk_ddr3.clk
 
	  //HPS ddr3
	  .memory_mem_a                          ( HPS_DDR3_ADDR),                       //                memory.mem_a
	  .memory_mem_ba                         ( HPS_DDR3_BA),                         //                .mem_ba
	  .memory_mem_ck                         ( HPS_DDR3_CK_P),                       //                .mem_ck
	  .memory_mem_ck_n                       ( HPS_DDR3_CK_N),                       //                .mem_ck_n
	  .memory_mem_cke                        ( HPS_DDR3_CKE),                        //                .mem_cke
	  .memory_mem_cs_n                       ( HPS_DDR3_CS_N),                       //                .mem_cs_n
	  .memory_mem_ras_n                      ( HPS_DDR3_RAS_N),                      //                .mem_ras_n
	  .memory_mem_cas_n                      ( HPS_DDR3_CAS_N),                      //                .mem_cas_n
	  .memory_mem_we_n                       ( HPS_DDR3_WE_N),                       //                .mem_we_n
	  .memory_mem_reset_n                    ( HPS_DDR3_RESET_N),                    //                .mem_reset_n
	  .memory_mem_dq                         ( HPS_DDR3_DQ),                         //                .mem_dq
	  .memory_mem_dqs                        ( HPS_DDR3_DQS_P),                      //                .mem_dqs
	  .memory_mem_dqs_n                      ( HPS_DDR3_DQS_N),                      //                .mem_dqs_n
	  .memory_mem_odt                        ( HPS_DDR3_ODT),                        //                .mem_odt
	  .memory_mem_dm                         ( HPS_DDR3_DM),                         //                .mem_dm
	  .memory_oct_rzqin                      ( HPS_DDR3_RZQ),                        //                .oct_rzqin

     .ddr3_hps_f2h_sdram0_clock_clk          (DDR3_CLK),          // ddr3_0_hps_f2h_sdram0_clock.clk
     .ddr3_hps_f2h_sdram0_data_address       (ddr3_avl_addr),       //  ddr3_0_hps_f2h_sdram0_data.address
     .ddr3_hps_f2h_sdram0_data_read          (ddr3_avl_read_req),          //                            .read
     .ddr3_hps_f2h_sdram0_data_readdata      (ddr3_avl_rdata),      //                            .readdata
     .ddr3_hps_f2h_sdram0_data_write         (ddr3_avl_write_req),         //                            .write
     .ddr3_hps_f2h_sdram0_data_writedata     (ddr3_avl_wdata),     //                            .writedata
     .ddr3_hps_f2h_sdram0_data_readdatavalid (ddr3_avl_rdata_valid), //                            .readdatavalid
     .ddr3_hps_f2h_sdram0_data_waitrequest   (ddr3_avl_ready),   //                            .waitrequest
     .ddr3_hps_f2h_sdram0_data_byteenable    (16'hffff),    //                            .byteenable
     .ddr3_hps_f2h_sdram0_data_burstcount    (ddr3_avl_size)     //                            .burstcount

	
	);
	
	
	

//DDR3 Verify 
wire ddr3_test_pass/*synthesis keep*/;
wire ddr3_test_fail/*synthesis keep*/;
wire ddr3_test_complete/*synthesis keep*/;

/////////////////// DDR3(A) Test ///////////////////
wire         ddr3_avl_ready;                  //          	 .avl.waitrequest
wire [25:0]  ddr3_avl_addr;                   //             .address
wire         ddr3_avl_rdata_valid;            //             .readdatavalid
wire [127:0] ddr3_avl_rdata;                  //             .readdata
wire [127:0] ddr3_avl_wdata;                  //             .writedata
wire         ddr3_avl_read_req;               //             .read
wire         ddr3_avl_write_req;              //             .write
wire [7:0]   ddr3_avl_size;                   //             .burstcount


Avalon_bus_RW_Test DDR3A_Verify(
		.iCLK(DDR3_CLK),
		.iRST_n(Debounce_KEY0),
		.insert_error(Debounce_KEY1),
		
		.avl_waitrequest(ddr3_avl_ready),                 
		.avl_address(ddr3_avl_addr),                      
		.avl_readdatavalid(ddr3_avl_rdata_valid),                 
		.avl_readdata(ddr3_avl_rdata),                      
		.avl_writedata(ddr3_avl_wdata),                     
		.avl_read(ddr3_avl_read_req),                          
		.avl_write(ddr3_avl_write_req),    
		.avl_size(ddr3_avl_size),
		.drv_status_pass(ddr3_test_pass),
		.drv_status_fail(ddr3_test_fail),
		.drv_status_test_complete(ddr3_test_complete)		
);

assign LED[0] = ~(KEY[0]);
assign LED[1] =  (ddr3_test_pass)?1'b1:1'b0;
assign LED[2] =  (ddr3_test_complete )?1'b1:1'b0;
assign LED[3] =  (ddr3_test_fail)?1'b1:1'b0;
assign LED[7] =  heart_beat[23];

reg [23:0] heart_beat;

assign GPIO_1[0] = Debounce_KEY0;
assign GPIO_1[1] = (ddr3_test_complete )?1'b1:1'b0;
assign GPIO_1[2] = (ddr3_test_pass )?1'b1:1'b0;

always @ (posedge FPGA_CLK2_50)
begin
	heart_beat <= heart_beat + 1;
end


// HDMI


//=======================================================
//  REG/WIRE declarations
//=======================================================
wire				reset_n;
wire				pll_1200k;
reg	[12:0]	counter_1200k;
reg				en_150;
wire				vpg_mode_change;
wire	[3:0]		vpg_mode;

//Video Pattern Generator
wire	[3:0]		vpg_disp_mode;
wire				vpg_pclk;
wire				vpg_de, vpg_hs, vpg_vs;
wire	[23:0]	vpg_data;

//=======================================================
//  Structural coding
//=======================================================
//assign LED[3:0] = vpg_mode;

//assign reset_n = 1'b1;

//system clock
sys_pll u_sys_pll (
	.refclk(FPGA_CLK1_50),
	.rst(!KEY[0]),
	.outclk_0(pll_1200k),		// 1.2M Hz
	.outclk_1(AUD_CTRL_CLK),	// 1.536M Hz
	.locked(reset_n) );


//pattern generator
vpg u_vpg (
	.clk_50(FPGA_CLK2_50),
	.reset_n(reset_n),
	.mode(vpg_mode),
	.mode_change(vpg_mode_change),
	.vpg_pclk(HDMI_TX_CLK),
	.vpg_de(HDMI_TX_DE),
	.vpg_hs(HDMI_TX_HS),
	.vpg_vs(HDMI_TX_VS),
	.vpg_r(HDMI_TX_D[23:16]),
	.vpg_g(HDMI_TX_D[15:8]),
	.vpg_b(HDMI_TX_D[7:0]) );

//HDMI I2C
I2C_HDMI_Config u_I2C_HDMI_Config (
	.iCLK(FPGA_CLK1_50),
	.iRST_N(reset_n),
	.I2C_SCLK(HDMI_I2C_SCL),
	.I2C_SDAT(HDMI_I2C_SDA),
	.HDMI_TX_INT(HDMI_TX_INT)
	 );


`include "vpg_source/vpg.h"
assign vpg_mode_change = 0;
assign vpg_mode = `VGA_640x480p60;


endmodule
